[{"C:\\Git\\algorithm-visualizer\\src\\index.js":"1","C:\\Git\\algorithm-visualizer\\src\\App.js":"2","C:\\Git\\algorithm-visualizer\\src\\serviceWorker.js":"3","C:\\Git\\algorithm-visualizer\\src\\BubbleSort.js":"4","C:\\Git\\algorithm-visualizer\\src\\About.js":"5","C:\\Git\\algorithm-visualizer\\src\\InsertionSort.js":"6","C:\\Git\\algorithm-visualizer\\src\\Explore.js":"7","C:\\Git\\algorithm-visualizer\\src\\Home.js":"8","C:\\Git\\algorithm-visualizer\\src\\components\\RedirectButton.js":"9","C:\\Git\\algorithm-visualizer\\src\\services\\arrayManager.js":"10","C:\\Git\\algorithm-visualizer\\src\\components\\ArraySorter.js":"11","C:\\Git\\algorithm-visualizer\\src\\components\\BottomBar.js":"12","C:\\Git\\algorithm-visualizer\\src\\components\\Header.js":"13","C:\\Git\\algorithm-visualizer\\src\\components\\Array.js":"14","C:\\Git\\algorithm-visualizer\\src\\algorithms\\sorting\\bubbleSort.js":"15","C:\\Git\\algorithm-visualizer\\src\\algorithms\\sorting\\insertionSort.js":"16","C:\\Git\\algorithm-visualizer\\src\\components\\Button.js":"17","C:\\Git\\algorithm-visualizer\\src\\components\\Bar.js":"18","C:\\Git\\algorithm-visualizer\\src\\services\\isSorted.js":"19"},{"size":472,"mtime":1610584668108,"results":"20","hashOfConfig":"21"},{"size":746,"mtime":1610584883865,"results":"22","hashOfConfig":"21"},{"size":5198,"mtime":1610584668108,"results":"23","hashOfConfig":"21"},{"size":474,"mtime":1610584668106,"results":"24","hashOfConfig":"21"},{"size":448,"mtime":1610584804349,"results":"25","hashOfConfig":"21"},{"size":483,"mtime":1610584668107,"results":"26","hashOfConfig":"21"},{"size":803,"mtime":1610584668107,"results":"27","hashOfConfig":"21"},{"size":1016,"mtime":1610584668107,"results":"28","hashOfConfig":"21"},{"size":508,"mtime":1610584668107,"results":"29","hashOfConfig":"21"},{"size":3137,"mtime":1610584668107,"results":"30","hashOfConfig":"21"},{"size":5989,"mtime":1610584668106,"results":"31","hashOfConfig":"21"},{"size":357,"mtime":1610584668106,"results":"32","hashOfConfig":"21"},{"size":397,"mtime":1610584668107,"results":"33","hashOfConfig":"21"},{"size":1561,"mtime":1610584668106,"results":"34","hashOfConfig":"21"},{"size":5952,"mtime":1610584668106,"results":"35","hashOfConfig":"21"},{"size":5870,"mtime":1610584668106,"results":"36","hashOfConfig":"21"},{"size":1139,"mtime":1610584668107,"results":"37","hashOfConfig":"21"},{"size":2132,"mtime":1610584668106,"results":"38","hashOfConfig":"21"},{"size":520,"mtime":1610584668107,"results":"39","hashOfConfig":"21"},{"filePath":"40","messages":"41","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"1wk9fh2",{"filePath":"42","messages":"43","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"44","messages":"45","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"46"},{"filePath":"47","messages":"48","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"46"},{"filePath":"49","messages":"50","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"46"},{"filePath":"51","messages":"52","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"46"},{"filePath":"53","messages":"54","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"46"},{"filePath":"55","messages":"56","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"46"},{"filePath":"57","messages":"58","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"46"},{"filePath":"59","messages":"60","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"61","usedDeprecatedRules":"46"},{"filePath":"62","messages":"63","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"46"},{"filePath":"64","messages":"65","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"46"},{"filePath":"66","messages":"67","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"46"},{"filePath":"68","messages":"69","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"46"},{"filePath":"70","messages":"71","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"72","usedDeprecatedRules":"46"},{"filePath":"73","messages":"74","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"75","usedDeprecatedRules":"46"},{"filePath":"76","messages":"77","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"46"},{"filePath":"78","messages":"79","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"46"},{"filePath":"80","messages":"81","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"46"},"C:\\Git\\algorithm-visualizer\\src\\index.js",[],"C:\\Git\\algorithm-visualizer\\src\\App.js",[],"C:\\Git\\algorithm-visualizer\\src\\serviceWorker.js",[],["82","83"],"C:\\Git\\algorithm-visualizer\\src\\BubbleSort.js",[],"C:\\Git\\algorithm-visualizer\\src\\About.js",[],"C:\\Git\\algorithm-visualizer\\src\\InsertionSort.js",[],"C:\\Git\\algorithm-visualizer\\src\\Explore.js",[],"C:\\Git\\algorithm-visualizer\\src\\Home.js",[],"C:\\Git\\algorithm-visualizer\\src\\components\\RedirectButton.js",[],"C:\\Git\\algorithm-visualizer\\src\\services\\arrayManager.js",["84"],"/**\r\n * Adds or removes a bar from the array\r\n * \r\n * @param {boolean} add indicated wheter a bar is to be added or removed\r\n */\r\nconst addBar = (add = true, bars) => ( add ? bars.concat(getRandomList(1)) :\r\n  bars.slice(0, bars.length - 1).map(bar => (bar))\r\n)\r\n\r\n/**\r\n * Returns the default list similar to that of the logo\r\n */\r\nconst getDefaultList = () => [\r\n  {\r\n    size: 40\r\n  },\r\n  {\r\n    size: 20\r\n  },\r\n  {\r\n    size: 80\r\n  },\r\n  {\r\n    size: 60\r\n  },\r\n  {\r\n    size: 100\r\n  }\r\n]\r\n\r\n/**\r\n * Returns a list with almost sorted list\r\n * \r\n * @param {Integer} size size of the array\r\n */\r\nconst getAlmostSortedList = (size) => {\r\n  let barList = []\r\n\r\n  for (let i = 0; i < size; i++) {\r\n    barList.push({\r\n      size: 100 * (i + 1) / (size + 1),\r\n      selected: false,\r\n      analyzed: false,\r\n    })\r\n  }\r\n\r\n  for (let i = Math.ceil(size / 10); i < size; i++) {\r\n    const bar1 = barList[Math.floor(Math.random() * size)]\r\n    const bar2 = barList[Math.floor(Math.random() * size)]\r\n    return barList.map(bar =>\r\n      bar === bar1 ? bar2 :\r\n        bar === bar2 ? bar1 :\r\n          bar\r\n    )\r\n  }\r\n}\r\n\r\n/**\r\n * Returns a list with randomly sized bars\r\n * \r\n * @param {Integer} size size of the array\r\n */\r\nconst getRandomList = (size) => {\r\n  let barList = []\r\n\r\n  for (let i = 0; i < size; i++) {\r\n    let size = Math.ceil(Math.random() * 100)\r\n\r\n    if (size < 10) {\r\n      size += 10\r\n    }\r\n\r\n    barList.push({\r\n      size: size,\r\n      selected: false,\r\n      analyzed: false,\r\n    })\r\n  }\r\n  return (barList)\r\n}\r\n\r\n/**\r\n * Selects a bar from the array and, if two bars are selected, switches them \r\n * \r\n * @param {int} firstBarIndex index of the bar to be selected\r\n * @param {array} bars array containig all the bars\r\n */\r\nconst selectBar = (firstBarIndex, bars) => {\r\n\r\n  if (bars[firstBarIndex].selected) {\r\n    return bars.map(bar => ({ ...bar, selected: false }))\r\n\r\n  } else {\r\n    let secondBarIndex = -1\r\n\r\n    for (let i = 0; i < bars.length; i++) {\r\n      if (bars[i].selected) {\r\n        secondBarIndex = i\r\n        break\r\n      }\r\n    }\r\n\r\n    if (secondBarIndex !== -1) {\r\n      return bars.map((bar, i) => {\r\n        switch (i) {\r\n        case firstBarIndex:\r\n          return { ...bars[secondBarIndex], selected: false }\r\n\r\n        case secondBarIndex:\r\n          return { ...bars[firstBarIndex], selected: false }\r\n\r\n        default:\r\n          return bar\r\n        }\r\n      })\r\n    } else {\r\n      return bars.map((bar, i) => i === firstBarIndex ? { ...bar, selected: true } : bar)\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Switches two bars reseting their selected and analyzed properties to false\r\n * \r\n * @param {Arrays of bars} bars \r\n * @param {Index of the first bar} firstBar \r\n * @param {Index of the second bar} secondBar \r\n */\r\nconst switchBars = (bars, firstBar, secondBar) => (\r\n  bars.map((bar, index) => (\r\n    index === firstBar ? { ...bar, size: bars[secondBar].size, selected: false } :\r\n      index === secondBar ? { ...bar, size: bars[firstBar].size, selected: false } :\r\n        bar\r\n  ))\r\n)\r\n\r\nexport default { addBar, getAlmostSortedList, getRandomList, selectBar, switchBars, getDefaultList }","C:\\Git\\algorithm-visualizer\\src\\components\\ArraySorter.js",[],"C:\\Git\\algorithm-visualizer\\src\\components\\BottomBar.js",[],"C:\\Git\\algorithm-visualizer\\src\\components\\Header.js",[],"C:\\Git\\algorithm-visualizer\\src\\components\\Array.js",[],"C:\\Git\\algorithm-visualizer\\src\\algorithms\\sorting\\bubbleSort.js",["85"],"import React from 'react'\r\nimport arrayManager from '../../services/arrayManager'\r\n\r\n/**\r\n * Returns the state of the algorithm\r\n * \r\n * @param {Bar[]} barArray              : an array with the bars to be sorted\r\n * @param {Boolean} isSorted            : if the array is sorted or not   \r\n * @param {Number} currentComplexity    : current complexity of the algorithm\r\n */\r\nconst defaultState = (barArray, sorted = false, currentComplexity = 0) => {\r\n  const algorithmStatus = sorted ? 'Finished sorting!' : 'Ready to start sorting!'\r\n  const analyzedBarsIndex = [-1, 0]\r\n  const upperbound = barArray.length - 1\r\n  const lowerbound = 0\r\n  const switched = false\r\n  const step = 0\r\n  const worseComplexity = (barArray.length * (barArray.length - 1)) / 2 + 1\r\n  const bestComplexity = barArray.length - 1\r\n\r\n  return [\r\n    {\r\n      algorithmStatus,\r\n      analyzedBarsIndex,\r\n      upperbound,\r\n      lowerbound,\r\n      sorted,\r\n      switched,\r\n      step,\r\n      worseComplexity,\r\n      bestComplexity,\r\n      currentComplexity,\r\n    },\r\n    barArray.map(bar => ({ ...bar, analyzed: false, sorted: sorted })),\r\n  ]\r\n}\r\n\r\n/**\r\n * Takes one step in the sorting algorithm\r\n * \r\n * @param {State} state : state of the algorithm\r\n * \r\n * @returns {State}     : new state of the algorithm\r\n */\r\nconst sort = (state) => {\r\n  const status = state[0]\r\n  const bars = state[1]\r\n\r\n  /**\r\n     * Returns the next two bars that will be analyzed by te algorithm\r\n     */\r\n  const getNextBars = () => (\r\n    status.analyzedBarsIndex[0] >= status.upperbound ? [0, 1] :\r\n      status.analyzedBarsIndex.map(bar => bar + 1)\r\n  )\r\n\r\n  /**\r\n     * Determines if the array is sorted\r\n     */\r\n  const getIsSorted = (greater) => (\r\n    (status.upperbound === 0) ||\r\n        (status.analyzedBarsIndex[1] === status.upperbound - 1 && !status.switched && !greater)\r\n  )\r\n\r\n  /**\r\n     * Compares two bars\r\n     */\r\n  const compareBars = () => {\r\n    // Holds the indexes of the bars being currently analyzed\r\n    const analyzedBarsIndex = getNextBars()\r\n\r\n    // Holds wheater the first bar is greater than the second\r\n    const greater = bars[analyzedBarsIndex[0]].size > bars[analyzedBarsIndex[1]].size\r\n\r\n    // Holds a new list of bars where only the analzed bars are orange\r\n    const newBars = bars.map((bar, index) => (\r\n      index === analyzedBarsIndex[0] ? { ...bar, sorted: false, analyzed: true } :\r\n        index === analyzedBarsIndex[1] ? { ...bar, sorted: false, analyzed: true } :\r\n          { ...bar, sorted: false, analyzed: false }\r\n    ))\r\n\r\n\r\n    return getIsSorted(greater) ? defaultState(newBars, true, status.currentComplexity + 1) : [\r\n      {\r\n        ...status,\r\n        algorithmStatus:\r\n                    greater ? 'Because the first bar is greater than the second they are switched' :\r\n                      'Because the first bar is not greater than the second they are left unchanged',\r\n        analyzedBarsIndex: analyzedBarsIndex,\r\n        greater: greater,\r\n        step: greater ? 1 : 0,\r\n        switched: analyzedBarsIndex[0] === 0 ? false : status.switched,\r\n        upperbound: analyzedBarsIndex[1] === status.upperbound ? status.upperbound - 1 : status.upperbound,\r\n        currentComplexity: status.currentComplexity + 1,\r\n      },\r\n      newBars\r\n    ]\r\n  }\r\n\r\n  /**\r\n     * Changes the two bars and updates the status\r\n     */\r\n  const changeBars = () => [\r\n    {\r\n      ...status,\r\n      algorithmStatus: 'Switched the two bars',\r\n      step: 0,\r\n      switched: true,\r\n    },\r\n    arrayManager.switchBars(bars, status.analyzedBarsIndex[0], status.analyzedBarsIndex[1])\r\n  ]\r\n\r\n\r\n  return status.step === 0 ? compareBars() : changeBars()\r\n}\r\n\r\n/**\r\n * Returns the name of the algorithm\r\n * \r\n * @returns {String}    : name of the sorting algorithm\r\n */\r\nconst name = () => 'Bubble Sort'\r\n\r\n/**\r\n * Returns the about section of the algorithm\r\n * \r\n * @returns {String}    : about section of the algorithm\r\n */\r\nconst about = () => (\r\n\r\n  <div className=\"BubbleSortAbout\">\r\n\r\n    <h3>\r\n            About Bubble Sort\r\n    </h3>\r\n\r\n    <p>\r\n            Bubble Sort is a sorting algorithm that repeatedly steps through the list, compares adjacent elements, and\r\n            swaps them if they are in the wrong order. After each pass through the list, the algorithm is sure that the\r\n            largest element is placed at the last index, which from that point on is no longer analyzed.\r\n      <br />\r\n      <br />\r\n            One of Bubble Sort's key strengths is its ability to detect that the list is sorted efficiently without\r\n            external help by recording if it had to switch any elements. If none were switched while iterating through the\r\n            list, the algorithm knows that all the list's items are in the correct location.\r\n    </p>\r\n\r\n    <h3>\r\n            How our Implementation Works\r\n    </h3>\r\n\r\n    <ul>\r\n      <li><strong>Blue: </strong>bar is selected by the user</li>\r\n      <li><strong>Orange: </strong>bar is currently analyzed</li>\r\n      <li><strong>Gray: </strong>bar is considered sorted by the algorithm</li>\r\n      <li><strong>Green: </strong>the list is sorted</li>\r\n    </ul>\r\n\r\n  </div>\r\n)\r\n\r\n/**\r\n * Returns a python implementation of the algorithm\r\n * \r\n * @returns {HTML}  : returns an implementation of the algorithm\r\n */\r\nconst implementation = () => (\r\n  <div className=\"BubbleSortImplementation\">\r\n\r\n    <h3>\r\n            Python Implementation\r\n    </h3>\r\n\r\n    <pre>\r\n      <code>\r\n        {\r\n          `def bubble_sort(array):\r\n    upperbound = len(array)\r\n    switched = True\r\n\r\n    while switched and upperbound > 1:\r\n        switched = False\r\n\r\n        for i in range(1, upperbound):\r\n\r\n            if array[i - 1] > array[i]:\r\n                switched = True\r\n                array[i - 1], array[i] = array[i], array[i - 1]\r\n\r\n    upperbound -= 1\r\n\r\nreturn array`}\r\n      </code>\r\n    </pre>\r\n  </div>\r\n)\r\n\r\nexport default { sort, defaultState, name, implementation, about }","C:\\Git\\algorithm-visualizer\\src\\algorithms\\sorting\\insertionSort.js",["86"],"import React from 'react'\r\nimport arrayManager from '../../services/arrayManager'\r\n\r\n/**\r\n * Returns the state of the algorithm\r\n * \r\n * @param {Bar[]} barArray              : an array with the bars to be sorted\r\n * @param {Boolean} isSorted            : if the array is sorted or not   \r\n * @param {Number} currentComplexity    : current complexity of the algorithm\r\n */\r\nconst defaultState = (barArray, sorted = false, currentComplexity = 0) => {\r\n  const algorithmStatus = sorted ? 'Finished sorting!' : 'Ready to start sorting!'\r\n  const analyzedBarsIndex = [-1, 0]\r\n  const maxAnalyzedBarsIndex = [-1, 0]\r\n  const upperbound = barArray.length - 1\r\n  const lowerbound = 0\r\n  const switched = false\r\n  const step = 0\r\n  const worseComplexity = (barArray.length * (barArray.length - 1)) / 2\r\n  const bestComplexity = barArray.length - 1\r\n\r\n  return [\r\n    {\r\n      algorithmStatus,\r\n      analyzedBarsIndex,\r\n      maxAnalyzedBarsIndex,\r\n      upperbound,\r\n      lowerbound,\r\n      sorted,\r\n      switched,\r\n      step,\r\n      worseComplexity,\r\n      bestComplexity,\r\n      currentComplexity,\r\n    },\r\n    barArray.map(bar => ({ ...bar, analyzed: false, sorted: sorted })),\r\n  ]\r\n}\r\n\r\n/**\r\n * Takes one step in the sorting algorithm\r\n * \r\n * @param {State} state : state of the algorithm\r\n * \r\n * @returns {State}     : new state of the algorithm\r\n */\r\nconst sort = (state) => {\r\n  const status = state[0]\r\n  const bars = state[1]\r\n\r\n  /**\r\n     * Returns the next two bars that will be analyzed by te algorithm\r\n     */\r\n  const compareNextBars = () => {\r\n    const maxAnalyzedBarsIndex = status.maxAnalyzedBarsIndex.map(index => index + 1)\r\n\r\n    if (!bars[maxAnalyzedBarsIndex[1]]) {\r\n      return defaultState(bars, true, status.currentComplexity)\r\n    }\r\n\r\n    const greater = bars[maxAnalyzedBarsIndex[1]].size > bars[maxAnalyzedBarsIndex[0]].size\r\n    const algorithmStatus = greater\r\n      ? 'Because the second bar is greater than the second, they are left unchanged and the algorithm continues'\r\n      : 'Because the first bar is greater than the second, they are switched and the algorithm starts analysing the bars to its left'\r\n    const newBars = bars.map((bar, index) => (\r\n      index === maxAnalyzedBarsIndex[0] || index === maxAnalyzedBarsIndex[1]\r\n        ? { ...bar, sorted: false, analyzed: true }\r\n        : { ...bar, sorted: false, analyzed: false }\r\n    ))\r\n\r\n    return [\r\n      {\r\n        ...status,\r\n        algorithmStatus: algorithmStatus,\r\n        analyzedBarsIndex: maxAnalyzedBarsIndex,\r\n        maxAnalyzedBarsIndex: maxAnalyzedBarsIndex,\r\n        step: greater ? 0 : 1,\r\n        lowerbound: status.lowerbound + 1,\r\n        currentComplexity: status.currentComplexity + 1\r\n      },\r\n      newBars\r\n    ]\r\n  }\r\n\r\n  /**\r\n     * Compares the previous bars\r\n     */\r\n  const comparePreviousBars = () => {\r\n\r\n    if (status.analyzedBarsIndex[0] === 0) {\r\n      return compareNextBars()\r\n    }\r\n\r\n    const analyzedBarsIndex = status.analyzedBarsIndex.map(index => index - 1)\r\n    const greater = bars[analyzedBarsIndex[1]].size > bars[analyzedBarsIndex[0]].size\r\n    const algorithmStatus = greater\r\n      ? 'Because the second bar is greater than the second, they are left unchanged and the algorithm goes back to where it left off'\r\n      : 'Because the first bar is greater than the second, they are switched and the algorithm continues to the left'\r\n    const newBars = bars.map((bar, index) => (\r\n      index === analyzedBarsIndex[0] || index === analyzedBarsIndex[1]\r\n        ? { ...bar, sorted: false, analyzed: true }\r\n        : { ...bar, sorted: false, analyzed: false }\r\n    ))\r\n\r\n    return [\r\n      {\r\n        ...status,\r\n        algorithmStatus,\r\n        analyzedBarsIndex,\r\n        step: greater ? 0 : 1,\r\n        currentComplexity: status.currentComplexity + 1\r\n      },\r\n      newBars\r\n    ]\r\n  }\r\n\r\n  /**\r\n     * Changes the two bars and updates the status\r\n     */\r\n  const switchBars = () => [\r\n    {\r\n      ...status,\r\n      algorithmStatus: 'Switched the two bars',\r\n      step: 2,\r\n    },\r\n    arrayManager.switchBars(bars, status.analyzedBarsIndex[0], status.analyzedBarsIndex[1])\r\n  ]\r\n\r\n\r\n  switch (status.step) {\r\n  case 0:\r\n    return compareNextBars\r\n\r\n  case 1:\r\n    return switchBars\r\n\r\n  case 2:\r\n    return comparePreviousBars\r\n\r\n  default:\r\n    console.log('Something went wrong')\r\n    return defaultState()\r\n  }\r\n}\r\n\r\n/**\r\n * Returns the name of the algorithm\r\n * \r\n * @returns {String}    : name of the sorting algorithm\r\n */\r\nconst name = () => 'Insertion Sort'\r\n\r\n/**\r\n * Returns the about section of the algorithm\r\n * \r\n * @returns {String}    : about section of the algorithm\r\n */\r\nconst about = () => (\r\n\r\n  <div className=\"InsertionSortAbout\">\r\n\r\n    <h3>\r\n            About Insertion Sort\r\n    </h3>\r\n\r\n    <p>\r\n            TODO\r\n    </p>\r\n\r\n    <h3>\r\n            How our Implementation Works\r\n    </h3>\r\n\r\n    <ul>\r\n      <li><strong>Blue: </strong>bar is selected by the user</li>\r\n      <li><strong>Orange: </strong>bar is currently analyzed</li>\r\n      <li><strong>Gray: </strong>bar is considered sorted by the algorithm</li>\r\n      <li><strong>Green: </strong>the list is sorted</li>\r\n    </ul>\r\n\r\n  </div>\r\n)\r\n\r\n/**\r\n * Returns a python implementation of the algorithm\r\n * \r\n * @returns {HTML}  : returns an implementation of the algorithm\r\n */\r\nconst implementation = () => (\r\n  <div className=\"BubbleSortImplementation\">\r\n\r\n    <h3>\r\n            Python Implementation\r\n    </h3>\r\n\r\n    <pre>\r\n      <code>\r\n        {`def insertion_sort(array):\r\n\r\nfor i in range(1, len(array)):\r\n    key = array[i]\r\n    j = i - 1\r\n\r\n    while j >= 0 and key < array[j]:\r\n        array[j + 1] = array[j]\r\n        j -= 1\r\n\r\n    array[j + 1] = key\r\n\r\nreturn array\r\n                `}\r\n      </code>\r\n    </pre>\r\n  </div>\r\n)\r\n\r\nexport default {\r\n  sort,\r\n  defaultState,\r\n  name,\r\n  implementation,\r\n  about\r\n}","C:\\Git\\algorithm-visualizer\\src\\components\\Button.js",[],"C:\\Git\\algorithm-visualizer\\src\\components\\Bar.js",[],"C:\\Git\\algorithm-visualizer\\src\\services\\isSorted.js",[],{"ruleId":"87","replacedBy":"88"},{"ruleId":"89","replacedBy":"90"},{"ruleId":"91","severity":1,"message":"92","line":137,"column":1,"nodeType":"93","endLine":137,"endColumn":101},{"ruleId":"91","severity":1,"message":"92","line":198,"column":1,"nodeType":"93","endLine":198,"endColumn":67},{"ruleId":"91","severity":1,"message":"92","line":217,"column":1,"nodeType":"93","endLine":223,"endColumn":2},"no-native-reassign",["94"],"no-negated-in-lhs",["95"],"import/no-anonymous-default-export","Assign object to a variable before exporting as module default","ExportDefaultDeclaration","no-global-assign","no-unsafe-negation"]